// 递归
/**
 * 递归行为和递归行为时间复杂度的估算
 *  递归方法找数组中的最大值，系统是怎样做的？
 * 	master 公式：
 *  T(N)= a*T(N/b)+O(N^d)
 *  T(N)：母问题数据规模
 *  a*T(N/b)：子问题的调用次数 * 子问题的数据规模
 *  O(N^d)：除去子问题的调用之外，剩余情况的时间复杂度
 * 
 * 	1. log(b, a) > d   ->  复杂度为 （N^log(b, a)） 	 
 * 	2. log(b, a) = d   ->  复杂度为 （N^d * logN） 	 
 * 	3. log(b, a) < d   ->  复杂度为 （N^d） 	 
 * 
 * 取某数据链的中点值：l + (r-l)/2  等价于 l + (r-l) >> 1
 */

// 归并排序
/**
 * 注解：
 * 	1. 整体是一个递归，左边及右边排好序，让整体有序
 * 	2. 让其整体有序的过程里用了外排序（通过两个指针分别指向两个数组的首地址，进行对比）的方法
 * 	3. 利用master公式进行事件复杂度的求解
 * 	4. merge 将通过外排序的未出现数值越界的数组进行合并与外排序的容器数组，merge合并需注意面对左组和右组相等的情况下左侧数组成员值优先
 * 
 * 	时间复杂度 O(N*logN)，额外的空间复杂度O(N)
 */


// 题目一：小和问题
// 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和：
let arr = [3, 5, 6, 7, 8, 9];
/**
 *	题解：
		O(N^2)： 每一次遍历当前数组元素左边的所有符合要求的数字进行相			加，等同等差数列，复杂度较高
		O(N*logN)： 顺序判断当前数组元素右侧比该元素大的值进行相加。
		通过merge的方式同样有同等效益，与常规merge的区别是面对左组和右组相等的情况下值比较时右侧优先，需要保证左侧元素作为小和成员时被所有值过滤
 */



// 题目二：逆序问题
// 在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。